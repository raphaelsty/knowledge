<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raphael Sourty - Personal Knowledge Search Engine</title>
    <meta name="description"
        content="Discover the personal knowledge search engine created by Raphael Sourty. A unique project featuring neural search, ColBERT re-ranking, and a 3D graph visualization of interconnected notes.">
    <meta name="google-site-verification" content="-1EjnablvRwJITZucFLU44nYtII1cXhq4Ra3okO13fg" />
    <meta name="keywords"
        content="Raphael Sourty, personal search engine, deep learning search engine and recommender systems">

    <link rel="canonical" href="https://raphaelsty.github.io/knowledge/">

    <meta name="author" content="Raphael Sourty">


    <link rel="apple-touch-icon" sizes="180x180" href="./favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon_io/favicon-16x16.png">
    <link rel="manifest" href="./favicon_io/site.webmanifest">

    <meta property="og:title" content="Raphael Sourty - Personal Knowledge Search Engine">
    <meta property="og:description" content="Personal Search Engine, RaphaÃ«l Sourty, Knowledge">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://github.com/raphaelsty/">
    <meta property="og:image" content="https://avatars.githubusercontent.com/u/24591024?v=4">


    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Raphael Sourty - Personal Knowledge Search Engine">
    <meta name="twitter:description" content="Personal Search Engine, RaphaÃ«l Sourty, Knowledge">
    <meta name="twitter:image" content="https://avatars.githubusercontent.com/u/24591024?v=4">

    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@graph": [
            {
                "@type": "Person",
                "name": "Raphael Sourty",
                "url": "https://github.com/raphaelsty/",
                "sameAs": [
                "https://twitter.com/raphaelsrty"
                ]
            },
            {
                "@type": "WebSite",
                "name": "Raphael Sourty's Personal Knowledge Search Engine",
                "url": "https://github.com/raphaelsty/",
                "author": {
                "@type": "Person",
                "name": "Raphael Sourty"
                },
                "description": "A personal search engine built by Raphael Sourty to explore interconnected notes using neural search and 3D graph visualizations.",
                "keywords": "Raphael Sourty, personal search engine, deep learning search engine and recommender systems"
            }
            ]
        }
    </script>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="searchbox">
        <div id="backsearch"></div>
    </div>

    <div class="graph" id="graph"></div>

    <div class="graph-legend" id="graph-legend">
        <div class="graph-legend-item">
            <span class="graph-legend-dot query"></span>
            <span>From documents</span>
        </div>
        <div class="graph-legend-item">
            <span class="graph-legend-dot retrieved"></span>
            <span>From query</span>
        </div>
        <div class="graph-legend-hint">
            Click to zoom | Double-click to expand
        </div>
    </div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
    <script src="https://unpkg.com/three-spritetext"></script>
    <script src="https://unpkg.com/react-force-graph-3d"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel" data-presets="react">
        const { useState, useEffect, useRef, useCallback } = React;
        const { createRoot } = ReactDOM;

        // Globally available libraries from the script tags above
        // ForceGraph3D, SpriteText, THREE

        const API_BASE_URL = "https://knowledge.fly.dev";
        const SEARCH_DEBOUNCE_MS = 400;
        const PLOT_DEBOUNCE_MS = 500;
        const INITIAL_FETCH_COUNT = 100;
        const RERANK_INACTIVITY_MS = 1000; // New: Constant for inactivity delay
        const SUMMARY_TOKEN_LIMIT = 30; // New: Constant for summary length

        /**
         * The main Search component that handles UI, state management,
         * and interaction with the backend and the ColBERT worker.
         */
        const Search = () => {
            // --- State Management ---
            const [query, setQuery] = useState("");
            const [selectedNode, setSelectedNode] = useState(null);
            const [documentsToFetch, setDocumentsToFetch] = useState();
            const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
            const [modelStatus, setModelStatus] = useState("Loading Script...");
            const [documents, setDocuments] = useState([]);
            const [isSortedByDate, setIsSortedByDate] = useState(false);
            const [resultsReranked, setResultsReranked] = useState(false);

            // --- Graph Interaction State ---
            const [highlightNodes, setHighlightNodes] = useState(new Set());
            const [highlightLinks, setHighlightLinks] = useState(new Set());
            const [graphData, setGraphData] = useState({ nodes: [], links: [] });

            // --- Refs ---
            const searchTimerRef = useRef(null);
            const plotTimerRef = useRef(null);
            const workerRef = useRef(null);
            const latestQueryIdRef = useRef(0);
            const graphRootRef = useRef(null);
            const rerankTimerRef = useRef(null);
            const fgRef = useRef(null);
            const lastClickTimeRef = useRef(0);

            // --- Function Declarations (in dependency order) ---

            /**
             * Safely unmounts the 3D graph React component.
             */
            const unmountGraph = useCallback(() => {
                if (graphRootRef.current) {
                    graphRootRef.current.unmount();
                    graphRootRef.current = null;
                }
            }, []);

            /**
             * Fetches the latest documents from the backend.
             */
            const fetchLatest = useCallback(() => {
                unmountGraph();
                fetch(`${API_BASE_URL}/latest/${INITIAL_FETCH_COUNT}`)
                    .then(res => res.json())
                    .then(data => setDocuments(data.documents))
                    .catch(error => console.error("[APP] Failed to fetch latest documents:", error));
            }, [unmountGraph]);

            /**
             * Fetches search results from the backend API.
             * The immediate re-ranking logic has been moved to a separate useEffect.
             */
            const search = useCallback((searchQuery, count, sortChronologically = false) => {
                if (!searchQuery.trim()) {
                    fetchLatest();
                    return;
                }
                const queryId = ++latestQueryIdRef.current;
                const sortType = sortChronologically ? 'true' : 'false';
                const nodeFilter = selectedNode || 'null';
                const endpoint = `${API_BASE_URL}/search/${sortType}/${nodeFilter}/${searchQuery.replace("/", "")}`;

                fetch(endpoint)
                    .then(res => res.json())
                    .then(data => {
                        const initialDocs = Object.values(data["documents"]).map(doc => ({ ...doc }));
                        setDocuments(initialDocs); // This will trigger the re-ranking useEffect
                    })
                    .catch(error => console.error(`[APP] Failed to fetch search results:`, error));
            }, [selectedNode, fetchLatest]); // modelStatus dependency removed

            /**
             * Preprocesses graph data to build neighbor and link references for highlighting.
             */
            const preprocessGraphData = useCallback((data) => {
                const nodeById = {};
                data.nodes.forEach(node => {
                    nodeById[node.id] = node;
                    node.neighbors = [];
                    node.links = [];
                });

                data.links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    const a = nodeById[sourceId];
                    const b = nodeById[targetId];
                    if (a && b) {
                        a.neighbors.push(b);
                        b.neighbors.push(a);
                        a.links.push(link);
                        b.links.push(link);
                    }
                });

                return data;
            }, []);

            /**
             * Handles hovering over a node in the 3D graph - triggers search.
             */
            const handleHoverNode = useCallback((hoveredNode) => {
                if (hoveredNode) {
                    setSelectedNode(hoveredNode.id);
                    search(`${query} ${hoveredNode.id}`, documentsToFetch);
                    window.history.pushState({}, null, `?query=${encodeURIComponent(query)}&node=${encodeURIComponent(hoveredNode.id)}`);
                }
            }, [query, search, documentsToFetch]);

            /**
             * Handles node hover for path highlighting.
             */
            const handleGraphNodeHover = useCallback((node) => {
                const newHighlightNodes = new Set();
                const newHighlightLinks = new Set();

                if (node) {
                    newHighlightNodes.add(node);
                    if (node.neighbors) {
                        node.neighbors.forEach(neighbor => newHighlightNodes.add(neighbor));
                    }
                    if (node.links) {
                        node.links.forEach(link => newHighlightLinks.add(link));
                    }
                }

                setHighlightNodes(newHighlightNodes);
                setHighlightLinks(newHighlightLinks);

                if (node) {
                    handleHoverNode(node);
                }
            }, [handleHoverNode]);

            /**
             * Handles link hover for highlighting.
             */
            const handleGraphLinkHover = useCallback((link) => {
                const newHighlightNodes = new Set();
                const newHighlightLinks = new Set();

                if (link) {
                    newHighlightLinks.add(link);
                    newHighlightNodes.add(link.source);
                    newHighlightNodes.add(link.target);
                }

                setHighlightNodes(newHighlightNodes);
                setHighlightLinks(newHighlightLinks);
            }, []);

            /**
             * Handles click on a node - zooms camera to it.
             */
            const handleGraphNodeClick = useCallback((node) => {
                const now = Date.now();
                const isDoubleClick = now - lastClickTimeRef.current < 300;
                lastClickTimeRef.current = now;

                if (isDoubleClick) {
                    // Double-click: expand neighbors
                    fetch(`${API_BASE_URL}/expand/${encodeURIComponent(node.id)}`)
                        .then(res => res.json())
                        .then(newData => {
                            setGraphData(prev => {
                                const existingNodeIds = new Set(prev.nodes.map(n => n.id));
                                const existingLinkKeys = new Set(prev.links.map(l => {
                                    const sId = typeof l.source === 'object' ? l.source.id : l.source;
                                    const tId = typeof l.target === 'object' ? l.target.id : l.target;
                                    return `${sId}-${tId}`;
                                }));

                                const newNodes = newData.nodes.filter(n => !existingNodeIds.has(n.id));
                                const newLinks = newData.links.filter(l => {
                                    const key = `${l.source}-${l.target}`;
                                    const reverseKey = `${l.target}-${l.source}`;
                                    return !existingLinkKeys.has(key) && !existingLinkKeys.has(reverseKey);
                                });

                                const merged = {
                                    nodes: [...prev.nodes, ...newNodes],
                                    links: [...prev.links, ...newLinks]
                                };

                                return preprocessGraphData(merged);
                            });
                        })
                        .catch(error => console.error("[APP] Failed to expand node:", error));
                } else {
                    // Single click: zoom to node
                    if (fgRef.current) {
                        const distance = 120;
                        const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
                        fgRef.current.cameraPosition(
                            { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
                            node,
                            2000
                        );
                    }
                    handleHoverNode(node);
                }
            }, [handleHoverNode, preprocessGraphData]);

            /**
             * Fetches data and renders the 3D force-directed graph with enhanced features.
             */
            const plot = useCallback((plotQuery, count) => {
                const graphContainer = document.getElementById('graph');
                if (isMobile || !plotQuery.trim()) {
                    unmountGraph();
                    return;
                }
                const endpoint = `${API_BASE_URL}/plot/8/${plotQuery.replace("/", "")}`;
                fetch(endpoint)
                    .then(res => res.json())
                    .then(data => {
                        if (!graphContainer) return;

                        const processedData = preprocessGraphData(data);
                        setGraphData(processedData);

                        if (!graphRootRef.current) {
                            graphRootRef.current = createRoot(graphContainer);
                        }
                        graphRootRef.current.render(
                            <ForceGraph3D
                                ref={fgRef}
                                graphData={processedData}
                                backgroundColor="#080808"
                                width={window.innerWidth / 2}
                                height={window.innerHeight}
                                showNavInfo={false}

                                // Minimal node representation
                                nodeVal={0.5}

                                // Very thin, very transparent lines
                                linkWidth={0.05}
                                linkOpacity={link => highlightLinks.has(link) ? 0.08 : 0.005}
                                linkColor={link => highlightLinks.has(link) ? '#ffffff' : 'rgba(255, 255, 255, 0.2)'}

                                // Subtle single particles
                                linkDirectionalParticles={1}
                                linkDirectionalParticleSpeed={0.003}
                                linkDirectionalParticleWidth={link => highlightLinks.has(link) ? 1 : 0.5}
                                linkDirectionalParticleColor={link => highlightLinks.has(link) ? '#ffffff' : 'rgba(255, 255, 255, 0.4)'}

                                // Clean text-only nodes - bigger text
                                nodeThreeObject={node => {
                                    const sprite = new SpriteText(node.id);
                                    const isHighlighted = highlightNodes.size === 0 || highlightNodes.has(node);

                                    sprite.color = isHighlighted ? node.color : 'rgba(255, 255, 255, 0.35)';
                                    sprite.textHeight = 6;
                                    sprite.fontSize = 140;
                                    sprite.fontFace = "Inter";
                                    sprite.fontWeight = isHighlighted ? "600" : "500";

                                    return sprite;
                                }}

                                // Minimal tooltip
                                nodeLabel={node => `
                                    <div style="background: rgba(0,0,0,0.85); padding: 6px 10px; border-radius: 4px; font-family: Inter, -apple-system, sans-serif; font-size: 11px; color: #fff; border: 1px solid rgba(255,255,255,0.1);">
                                        ${node.id}
                                    </div>
                                `}

                                // Interactions
                                onNodeClick={handleGraphNodeClick}
                                onNodeHover={handleGraphNodeHover}
                                onLinkHover={handleGraphLinkHover}

                                // Physics
                                cooldownTicks={100}
                                d3AlphaDecay={0.02}
                                d3VelocityDecay={0.3}

                                // Camera - closer zoom
                                cameraPosition={{ x: 0, y: 0, z: 140 }}
                            />
                        );
                    }).catch(error => console.error("[APP] Failed to plot graph:", error));
            }, [isMobile, unmountGraph, preprocessGraphData, handleGraphNodeClick, handleGraphNodeHover, handleGraphLinkHover, highlightNodes, highlightLinks]);

            /**
             * A utility to run search and plot immediately, clearing any pending debounced calls.
             */
            const runNow = useCallback((runQuery, runCount, sortChronologically = true) => {
                setResultsReranked(false); // New: Reset re-rank status
                clearTimeout(rerankTimerRef.current); // New: Clear inactivity timer
                clearTimeout(searchTimerRef.current);
                clearTimeout(plotTimerRef.current);
                search(runQuery, runCount, sortChronologically);
                plot(runQuery, runCount);
            }, [search, plot]);

            // --- Effects ---

            /**
             * Initializes the Web Worker on component mount and sets up message handling.
             */
            useEffect(() => {
                const worker = new Worker('colbert.worker.js', { type: 'module' });
                workerRef.current = worker;
                worker.postMessage({ type: 'load' });

                worker.onmessage = event => {
                    const { type, payload, queryId } = event.data;
                    switch (type) {
                        case 'status':
                            setModelStatus(payload);
                            break;
                        case 'model-ready':
                            setModelStatus("Model Ready");
                            break;
                        case 'rank-update':
                        case 'rank-complete':
                            if (queryId === latestQueryIdRef.current) {
                                setDocuments(payload);
                                setResultsReranked(true); // New: Flag that results are now re-ranked
                            }
                            break;
                        case 'error':
                            setModelStatus(payload);
                            console.error("[APP] Received error from worker:", payload);
                            break;
                    }
                };

                return () => worker.terminate();
            }, []);

            /**
             * Effect to handle initial page load, parsing query params from the URL.
             */
            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const urlQuery = params.get("query") || "";
                const urlNode = params.get("node") || null;
                if (urlQuery) {
                    setQuery(urlQuery);
                    if (urlNode) {
                        setSelectedNode(urlNode);
                        runNow(`${urlQuery} ${urlNode}`, documentsToFetch);
                    } else {
                        runNow(urlQuery, documentsToFetch, true);
                    }
                } else {
                    fetchLatest();
                }
            }, []);

            /**
             * Effect to handle window resizing for mobile detection.
             */
            useEffect(() => {
                const handleResize = () => setIsMobile(window.innerWidth <= 768);
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            /**
             * New: Effect to automatically re-rank results after a period of inactivity.
             */
            useEffect(() => {
                clearTimeout(rerankTimerRef.current);

                const shouldAttemptRerank =
                    modelStatus === 'Model Ready' &&
                    !resultsReranked &&
                    documents.length > 0 &&
                    query.trim() &&
                    !isSortedByDate;

                if (shouldAttemptRerank) {
                    rerankTimerRef.current = setTimeout(() => {
                        workerRef.current.postMessage({
                            type: 'rank',
                            payload: { query, documents, queryId: latestQueryIdRef.current }
                        });
                    }, RERANK_INACTIVITY_MS);
                }

                return () => clearTimeout(rerankTimerRef.current);
            }, [documents, query, modelStatus, resultsReranked, isSortedByDate]);


            // --- Event Handlers ---

            /**
             * Handles user input in the search box with debouncing.
             */
            const handleChangeText = useCallback((event) => {
                const newQuery = event.target.value.toLowerCase();
                setQuery(newQuery);
                setSelectedNode(null);
                setIsSortedByDate(false);
                setResultsReranked(false); // New: Reset re-rank status on new input
                window.history.pushState({}, null, `?query=${encodeURIComponent(newQuery)}`);

                clearTimeout(rerankTimerRef.current); // New: Clear inactivity timer on new input
                clearTimeout(searchTimerRef.current);
                clearTimeout(plotTimerRef.current);
                searchTimerRef.current = setTimeout(() => search(newQuery, documentsToFetch), SEARCH_DEBOUNCE_MS);
                plotTimerRef.current = setTimeout(() => plot(newQuery, documentsToFetch), PLOT_DEBOUNCE_MS);
            }, [documentsToFetch, search, plot]);

            /**
             * Toggles the sort order between date and relevance.
             */
            const handleClickDate = useCallback(() => {
                const newSortState = !isSortedByDate;
                setIsSortedByDate(newSortState);
                setResultsReranked(false); // New: Reset re-rank status
                clearTimeout(rerankTimerRef.current); // New: Clear inactivity timer
                search(query, documentsToFetch, newSortState);
            }, [isSortedByDate, query, documentsToFetch, search]);

            /**
             * Adds a clicked tag to the current search query.
             */
            const handleClickTag = useCallback((tag) => {
                const newQuery = `${query} ${tag}`.trim();
                setQuery(newQuery);
                setIsSortedByDate(false);
                setResultsReranked(false); // New: Reset re-rank status
                const searchInput = document.getElementById("search");
                if (searchInput) searchInput.value = newQuery;
                window.history.pushState({}, null, `?query=${encodeURIComponent(newQuery)}`);
                runNow(newQuery, documentsToFetch, true);
            }, [query, documentsToFetch, runNow]);

            // --- UI Helper Functions ---

            /**
             * UPDATED: Returns a logo based on the document's source.
             * Uses an <img> tag for GitHub and emojis for others.
             */
            const getLinkLogo = (doc) => {
                const url = doc.url || "";
                const title = (doc.title || "").toLowerCase();
                const allTags = (doc.tags || []).concat(doc["extra-tags"] || []);
                const hasHackerNewsTag = allTags.some(tag => (tag || "").toLowerCase().includes("hackernews"));

                if (url.includes("github.com")) {
                    return <img src="github.png" alt="GitHub Logo" />;
                }
                if (url.includes("twitter.com")) {
                    return <img src="twitter.png" alt="Twitter Logo" />;
                }
                if (title.includes("hackernews") || hasHackerNewsTag) {
                    return <img src="hackernews.png" alt="Hackernews Logo" />;
                }
                return 'ðŸ“„';
            };

            /**
             * Determines the CSS class for the status indicator light.
             */
            const getIndicatorClass = (status) => {
                if (status === "Model Ready") return 'status-ready';
                if (status.startsWith("Error")) return 'status-error';
                return 'status-loading';
            };

            /**
             * UPDATED: Truncates text and normalizes whitespace.
             */
            const truncate = (text, limit) => {
                if (!text) return "";
                // Trim whitespace from ends, then split by one or more spaces.
                const tokens = text.trim().split(/\s+/);

                if (tokens.length <= limit) {
                    return tokens.join(' '); // Re-join to ensure single spaces.
                }

                return tokens.slice(0, limit).join(" ") + "...";
            };

            /**
             * Wraps matching keywords in a span to highlight them.
             */
            const highlight = useCallback((text) => {
                if (!text) return "";
                let keywords = query;
                if (selectedNode) keywords += ` ${selectedNode}`;
                const keywordSet = new Set(keywords.toLowerCase().split(/\s+/).filter(token => token.length > 2));
                if (keywordSet.size === 0) return <div className="inline">{text}</div>;

                const parts = text.split(new RegExp(`(${Array.from(keywordSet).join("|")})`, 'gi'));
                return (
                    <div className="inline">
                        {parts.map((part, i) =>
                            keywordSet.has(part.toLowerCase())
                                ? <div className="highlight" key={i}>{part}</div>
                                : part
                        )}
                    </div>
                );
            }, [query, selectedNode]);

            // --- Render ---
            return (
                <React.Fragment>
                    <div id="search-container">
                        <input
                            id="search"
                            type="textarea"
                            placeholder="Neural Search"
                            value={query}
                            onChange={handleChangeText}
                            autoFocus
                        />
                        <span
                            className={`status-indicator ${getIndicatorClass(modelStatus)}`}
                            title={modelStatus}>
                        </span>
                    </div>

                    <div id="documents">
                        {(documents || []).map((doc, index) => (
                            <div className="document" key={doc.url || index}>
                                <div className="title-wrapper">
                                    <span className="logo">{getLinkLogo(doc)}</span>
                                    <a className="title" href={doc.url} target="_blank" rel="noopener noreferrer">
                                        {highlight(doc.title)}
                                    </a>
                                </div>
                                <div className="date" onClick={handleClickDate}>
                                    {highlight(doc.date)}
                                </div>
                                <div className="summary">
                                    {highlight(truncate(doc.summary, SUMMARY_TOKEN_LIMIT))}
                                </div>
                                <div className="tags">
                                    {(doc.tags || []).concat(doc["extra-tags"] || []).map((tag, i) => (
                                        <div className="tag" key={i} onClick={() => handleClickTag(tag)}>
                                            {highlight(tag)}
                                        </div>
                                    ))}
                                    {typeof doc.colbertScore === 'number' ? (
                                        <span className="score-badge reranker-score" title="Re-ranker Score">
                                            {doc.colbertScore.toFixed(3)}
                                        </span>
                                    ) : typeof doc.similarity === 'number' ? (
                                        <span className="score-badge retriever-score" title="Retriever Score">
                                            {doc.similarity.toFixed(3)}
                                        </span>
                                    ) : null}
                                </div>
                            </div>
                        ))}
                    </div>
                </React.Fragment>
            );
        };

        // --- Mount Application ---
        const container = document.getElementById('backsearch');
        const root = createRoot(container);
        root.render(<Search />);
    </script>
</body>

</html>
